<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HRU Climate Data Analysis</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script type="importmap">
    {
        "imports": {
            "@duckdb/duckdb-wasm": "https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.28.1-dev106.0/+esm"
        }
    }
    </script>
</head>
<body class="container mt-5">
    <header class="text-center mb-5">
        <h1>HRU Climate Data Analysis</h1>
        <nav class="mt-3">
            <div class="btn-group" role="group" aria-label="Navigation">
                <a href="index.html" class="btn btn-outline-primary">Data Analysis</a>
                <a href="map.html" class="btn btn-outline-primary">Spatial Map</a>
                <a href="hru_analysis.html" class="btn btn-primary">HRU Analysis</a>
                <a href="debug.html" class="btn btn-outline-secondary">Debug</a>
            </div>
        </nav>
    </header>
    <main>
        <section class="mb-4">
            <p>Analyze Hydrologic Response Unit (HRU) climate data from different models and scenarios.</p>
            
            <!-- Model and Location Selection -->
            <div class="card mb-4">
                <div class="card-header">
                    <h5 class="mb-0">üìç Data Selection</h5>
                </div>
                <div class="card-body">
                    <div class="row">
                        <div class="col-md-4">
                            <label for="model-container" class="form-label">Climate Models</label>
                            <div id="model-container">
                                <button id="add-model" class="btn btn-outline-info btn-sm">+ Add Model</button>
                            </div>
                        </div>
                        <div class="col-md-4">
                            <label for="grid-select" class="form-label">Grid Location</label>
                            <select id="grid-select" class="form-select">
                                <option value="">Select a grid...</option>
                            </select>
                        </div>
                        <div class="col-md-4">
                            <label for="hru-container" class="form-label">HRU Types & Areas</label>
                            <div id="hru-container">
                                <button id="add-hru" class="btn btn-outline-success btn-sm">+ Add HRU</button>
                            </div>
                        </div>
                    </div>
                    <div class="row mt-3">
                        <div class="col-12">
                            <div class="form-text mb-2">Current Data Source:</div>
                            <div class="input-group">
                                <input type="text" id="data-source" class="form-control" readonly 
                                       placeholder="Select model, grid, and HRU to generate data source URL">
                                <button id="load-data" class="btn btn-primary" type="button" disabled>
                                    <span id="load-status">üìä</span> Load Data
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Data Summary -->
            <div id="data-summary" class="card mb-4" style="display: none;">
                <div class="card-header">
                    <h5 class="mb-0">üìà Data Summary</h5>
                </div>
                <div class="card-body">
                    <div class="row">
                        <div class="col-md-3">
                            <div class="text-center">
                                <h6 class="text-muted">Total Records</h6>
                                <span id="total-records" class="h4 text-primary">-</span>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="text-center">
                                <h6 class="text-muted">Date Range</h6>
                                <span id="date-range" class="h6 text-info">-</span>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="text-center">
                                <h6 class="text-muted">Available Columns</h6>
                                <span id="column-count" class="h4 text-success">-</span>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="text-center">
                                <h6 class="text-muted">HRU Info</h6>
                                <span id="hru-info" class="h6 text-warning">-</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Analysis Tools -->
            <div id="analysis-section" class="card mb-4" style="display: none;">
                <div class="card-header">
                    <h5 class="mb-0">üîç Analysis Tools</h5>
                </div>
                <div class="card-body">
                    <div class="row">
                        <div class="col-md-6">
                            <label for="variable-select" class="form-label">Variable to Analyze</label>
                            <select id="variable-select" class="form-select">
                                <option value="suro+ifwo" selected>suro+ifwo (Surface Runoff + Interflow)</option>
                            </select>
                            <div class="form-text">Analyzing combined surface runoff and interflow in liters per second (L/s)</div>
                        </div>
                        <div class="col-md-2">
                            <label for="aggregation-select" class="form-label">Aggregation</label>
                            <select id="aggregation-select" class="form-select">
                                <option value="daily">Daily</option>
                                <option value="monthly">Monthly</option>
                                <option value="yearly">Yearly</option>
                            </select>
                        </div>
                        <div class="col-md-2">
                            <label for="chart-type-select" class="form-label">Chart Type</label>
                            <select id="chart-type-select" class="form-select">
                                <option value="individual">Individual Models</option>
                                <option value="range">Model Range (Shaded)</option>
                            </select>
                        </div>
                        <div class="col-md-2">
                            <button id="analyze-data" class="btn btn-success mt-4" type="button">
                                üìä Analyze
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Visualization -->
            <div id="chart-section" class="card mb-4" style="display: none;">
                <div class="card-header">
                    <h5 class="mb-0">üìà Time Series Visualization</h5>
                </div>
                <div class="card-body">
                    <div style="height: 400px; position: relative;">
                        <canvas id="time-series-chart"></canvas>
                    </div>
                </div>
            </div>

            <!-- Data Table -->
            <div id="table-section" class="card" style="display: none;">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="mb-0">üìã Data Table</h5>
                    <button id="download-csv" class="btn btn-outline-primary btn-sm">
                        üìÅ Download CSV
                    </button>
                </div>
                <div class="card-body">
                    <div id="table-container"></div>
                    <div id="pagination-container" class="mt-3"></div>
                </div>
            </div>

        </section>
    </main>

    <!-- Status Messages -->
    <div id="status-message" class="alert" style="display: none;"></div>

    <script type="module">
        import * as duckdb from '@duckdb/duckdb-wasm';

        // Global variables
        let db;
        let currentData = [];
        let chart = null;
        let currentPage = 1;
        const rowsPerPage = 20;

        // DOM elements
        const modelContainer = document.getElementById('model-container');
        const addModelButton = document.getElementById('add-model');
        const gridSelect = document.getElementById('grid-select');
        const hruContainer = document.getElementById('hru-container');
        const addHruButton = document.getElementById('add-hru');
        const dataSource = document.getElementById('data-source');
        const loadDataButton = document.getElementById('load-data');
        const statusMessage = document.getElementById('status-message');

        // Model and HRU management
        let selectedModels = [];
        let selectedHrus = [];
        let modelData = [];
        let hruData = [];
        let modelCounter = 0;
        let hruCounter = 0;

        // Initialize DuckDB
        async function initDuckDB() {
            try {
                showStatus('Initializing DuckDB...', 'info');
                const bundle = await duckdb.selectBundle(duckdb.getJsDelivrBundles());
                const worker = await duckdb.createWorker(bundle.mainWorker);
                db = new duckdb.AsyncDuckDB(new duckdb.ConsoleLogger(), worker);
                await db.instantiate(bundle.mainModule, bundle.pthreadWorker);
                
                await db.open({
                    query: {
                        castBigIntToDouble: true,
                    },
                });

                showStatus('DuckDB initialized successfully!', 'success');
                return true;
            } catch (error) {
                console.error('Failed to initialize DuckDB:', error);
                showStatus('Failed to initialize DuckDB: ' + error.message, 'danger');
                return false;
            }
        }

        // Load data from JSON files
        async function loadSelectionData() {
            try {
                // Load model names
                const modelResponse = await fetch('data/model_names.json');
                const modelJson = await modelResponse.json();
                modelData = modelJson.model_names;

                // Load grid names
                const gridResponse = await fetch('data/grid_names.json');
                const gridData = await gridResponse.json();
                gridData.grid_names.forEach(grid => {
                    const option = document.createElement('option');
                    option.value = grid;
                    option.textContent = grid;
                    gridSelect.appendChild(option);
                });

                // Load HRU data
                const hruResponse = await fetch('data/hrus.json');
                hruData = await hruResponse.json();

            } catch (error) {
                console.error('Error loading selection data:', error);
                showStatus('Error loading selection data: ' + error.message, 'danger');
            }
        }

        // Add model selection row
        function addModelRow() {
            modelCounter++;
            const modelRow = document.createElement('div');
            modelRow.className = 'model-row mb-2';
            modelRow.id = `model-row-${modelCounter}`;
            
            modelRow.innerHTML = `
                <div class="input-group input-group-sm">
                    <select class="form-select model-select" data-id="${modelCounter}">
                        <option value="">Select Model...</option>
                        ${modelData.map(model => `<option value="${model}">${model}</option>`).join('')}
                    </select>
                    <button class="btn btn-outline-danger" type="button" onclick="removeModelRow(${modelCounter})">
                        √ó
                    </button>
                </div>
            `;
            
            modelContainer.insertBefore(modelRow, addModelButton);
            
            // Add event listener
            const select = modelRow.querySelector('.model-select');
            select.addEventListener('change', updateSelectedModels);
        }

        // Remove model row
        window.removeModelRow = function(id) {
            const row = document.getElementById(`model-row-${id}`);
            if (row) {
                row.remove();
                updateSelectedModels();
            }
        };

        // Update selected models array
        function updateSelectedModels() {
            selectedModels = [];
            const rows = document.querySelectorAll('.model-row');
            
            rows.forEach(row => {
                const select = row.querySelector('.model-select');
                if (select.value) {
                    selectedModels.push(select.value);
                }
            });
            
            updateDataSource();
        }

        // Add HRU selection row
        function addHruRow() {
            hruCounter++;
            const hruRow = document.createElement('div');
            hruRow.className = 'hru-row mb-2';
            hruRow.id = `hru-row-${hruCounter}`;
            
            hruRow.innerHTML = `
                <div class="input-group input-group-sm">
                    <select class="form-select hru-select" data-id="${hruCounter}">
                        <option value="">Select HRU...</option>
                        ${hruData.map(hru => `<option value="${hru.hru_name}">${hru.hru_name} - ${hru.Label}</option>`).join('')}
                    </select>
                    <input type="number" class="form-control hru-area" data-id="${hruCounter}" 
                           placeholder="Area (m¬≤)" min="0" step="0.01">
                    <button class="btn btn-outline-danger" type="button" onclick="removeHruRow(${hruCounter})">
                        √ó
                    </button>
                </div>
            `;
            
            hruContainer.insertBefore(hruRow, addHruButton);
            
            // Add event listeners
            const select = hruRow.querySelector('.hru-select');
            const area = hruRow.querySelector('.hru-area');
            select.addEventListener('change', updateSelectedHrus);
            area.addEventListener('input', updateSelectedHrus);
        }

        // Remove HRU row
        window.removeHruRow = function(id) {
            const row = document.getElementById(`hru-row-${id}`);
            if (row) {
                row.remove();
                updateSelectedHrus();
            }
        };

        // Update selected HRUs array
        function updateSelectedHrus() {
            selectedHrus = [];
            const rows = document.querySelectorAll('.hru-row');
            
            rows.forEach(row => {
                const select = row.querySelector('.hru-select');
                const area = row.querySelector('.hru-area');
                
                if (select.value && area.value && parseFloat(area.value) > 0) {
                    const hruInfo = hruData.find(h => h.hru_name === select.value);
                    selectedHrus.push({
                        hru_name: select.value,
                        area: parseFloat(area.value),
                        label: hruInfo ? hruInfo.Label : select.value
                    });
                }
            });
            
            updateDataSource();
        }

        // Update data source URL
        function updateDataSource() {
            const grid = gridSelect.value;
            const hasValidModels = selectedModels.length > 0;
            const hasValidHrus = selectedHrus.length > 0;

            if (hasValidModels && grid && hasValidHrus) {
                const totalArea = selectedHrus.reduce((sum, hru) => sum + hru.area, 0);
                const modelList = selectedModels.join(', ');
                const hruList = selectedHrus.map(hru => hru.hru_name).join(', ');
                dataSource.value = `${selectedModels.length} Models (${modelList}) | ${selectedHrus.length} HRUs (${hruList}) | Total Area: ${totalArea.toLocaleString()} m¬≤`;
                loadDataButton.disabled = false;
            } else {
                dataSource.value = '';
                loadDataButton.disabled = true;
            }
        }

        // Show status message
        function showStatus(message, type) {
            statusMessage.className = `alert alert-${type}`;
            statusMessage.textContent = message;
            statusMessage.style.display = 'block';
            setTimeout(() => {
                statusMessage.style.display = 'none';
            }, 5000);
        }

        // Load and analyze data
        async function loadData() {
            if (!db || selectedModels.length === 0 || selectedHrus.length === 0) return;

            try {
                showStatus('Loading data for multiple models and HRUs...', 'info');
                loadDataButton.disabled = true;

                const conn = await db.connect();
                const grid = gridSelect.value;
                
                // Check each model/HRU combination and get basic info
                let totalRecords = 0;
                let dateRange = 'N/A';
                let allColumns = new Set();
                let loadedCombinations = 0;
                const totalCombinations = selectedModels.length * selectedHrus.length;
                
                for (const model of selectedModels) {
                    for (const hru of selectedHrus) {
                        const url = `https://storage.googleapis.com/climate_ts/${model}/results/${grid}/${hru.hru_name}.parquet`;
                        
                        try {
                            // Get basic info about this model/HRU dataset
                            const countResult = await conn.query(`SELECT COUNT(*) as count FROM '${url}'`);
                            const countData = countResult.toArray().map(row => row.toJSON());
                            totalRecords = countData[0].count; // All datasets should have same number of records
                            
                            // Get column names
                            const schemaResult = await conn.query(`DESCRIBE SELECT * FROM '${url}' LIMIT 1`);
                            const schemaData = schemaResult.toArray().map(row => row.toJSON());
                            schemaData.forEach(col => allColumns.add(col.column_name));
                            
                            // Get date range from first dataset only
                            if (dateRange === 'N/A' && allColumns.has('ix')) {
                                const sampleResult = await conn.query(`SELECT MIN(ix) as min_ix, MAX(ix) as max_ix FROM '${url}'`);
                                const sampleData = sampleResult.toArray().map(row => row.toJSON());
                                const minIx = sampleData[0].min_ix;
                                const maxIx = sampleData[0].max_ix;
                                
                                const startDate = new Date('1981-01-01');
                                const minDate = new Date(startDate.getTime() + minIx * 60 * 60 * 1000);
                                const maxDate = new Date(startDate.getTime() + maxIx * 60 * 60 * 1000);
                                dateRange = `${minDate.toLocaleDateString()} - ${maxDate.toLocaleDateString()}`;
                            }
                            
                            loadedCombinations++;
                        } catch (error) {
                            showStatus(`Error loading ${model}/${hru.hru_name}: ${error.message}`, 'warning');
                        }
                    }
                }

                conn.close();

                // Update summary
                const totalArea = selectedHrus.reduce((sum, hru) => sum + hru.area, 0);
                
                document.getElementById('total-records').textContent = totalRecords.toLocaleString();
                document.getElementById('date-range').textContent = dateRange;
                document.getElementById('column-count').textContent = allColumns.size;
                document.getElementById('hru-info').textContent = `${selectedModels.length} Models | ${selectedHrus.length} HRUs | ${totalArea.toLocaleString()} m¬≤ total`;

                // Check if required columns exist for suro+ifwo calculation
                const hasSuro = allColumns.has('suro');
                const hasIfwo = allColumns.has('ifwo');
                
                if (!hasSuro || !hasIfwo) {
                    showStatus(`Warning: Missing required columns. Found: ${Array.from(allColumns).join(', ')}. Need 'suro' and 'ifwo' for analysis.`, 'warning');
                }

                // Show sections
                document.getElementById('data-summary').style.display = 'block';
                document.getElementById('analysis-section').style.display = 'block';

                showStatus(`Data loaded successfully for ${selectedModels.length} models and ${selectedHrus.length} HRUs (${loadedCombinations}/${totalCombinations} combinations)!`, 'success');
                loadDataButton.disabled = false;

            } catch (error) {
                console.error('Error loading data:', error);
                showStatus('Error loading data: ' + error.message, 'danger');
                loadDataButton.disabled = false;
            }
        }

        // Analyze data and create visualization
        async function analyzeData() {
            const aggregation = document.getElementById('aggregation-select').value;
            const chartType = document.getElementById('chart-type-select').value;
            
            if (!db || selectedModels.length === 0 || selectedHrus.length === 0) return;

            try {
                showStatus('Analyzing multi-model suro+ifwo data (converting to L/s)...', 'info');
                
                const conn = await db.connect();
                const grid = gridSelect.value;
                const totalArea = selectedHrus.reduce((sum, hru) => sum + hru.area, 0);

                // Build queries for each model separately to allow comparison
                const modelQueries = selectedModels.map(model => {
                    const hruQueries = selectedHrus.map(hru => {
                        const url = `https://storage.googleapis.com/climate_ts/${model}/results/${grid}/${hru.hru_name}.parquet`;
                        // Convert from mm to L/s: 
                        // mm * m¬≤ * (1 m / 1000 mm) * (1000 L / 1 m¬≥) * (1 hour / 3600 seconds)
                        // = mm * m¬≤ * (1/1000) * (1000) * (1/3600) = mm * m¬≤ / 3600
                        const conversionFactor = hru.area / 3600; // mm*m¬≤/hour to L/s
                        
                        return `
                            SELECT 
                                ix,
                                (suro + ifwo) * ${conversionFactor} as flow_ls,
                                '${model}' as model_name,
                                '${hru.hru_name}' as hru_name,
                                ${hru.area} as area
                            FROM '${url}' 
                            WHERE ix IS NOT NULL AND suro IS NOT NULL AND ifwo IS NOT NULL
                        `;
                    });
                    
                    return hruQueries.join(' UNION ALL ');
                });

                let query;
                if (aggregation === 'daily') {
                    query = `
                        WITH combined_data AS (
                            ${modelQueries.join(' UNION ALL ')}
                        )
                        SELECT 
                            DATE_TRUNC('day', '1981-01-01'::TIMESTAMP + INTERVAL (ix) HOUR) as date,
                            model_name,
                            SUM(flow_ls) as total_flow,
                            AVG(flow_ls) as avg_flow,
                            MIN(flow_ls) as min_flow,
                            MAX(flow_ls) as max_flow
                        FROM combined_data
                        GROUP BY date, model_name
                        ORDER BY date, model_name
                        LIMIT 2000
                    `;
                } else if (aggregation === 'monthly') {
                    query = `
                        WITH combined_data AS (
                            ${modelQueries.join(' UNION ALL ')}
                        )
                        SELECT 
                            DATE_TRUNC('month', '1981-01-01'::TIMESTAMP + INTERVAL (ix) HOUR) as date,
                            model_name,
                            AVG(flow_ls) as total_flow,
                            AVG(flow_ls) as avg_flow,
                            MIN(flow_ls) as min_flow,
                            MAX(flow_ls) as max_flow
                        FROM combined_data
                        GROUP BY date, model_name
                        ORDER BY date, model_name
                    `;
                } else { // yearly
                    query = `
                        WITH combined_data AS (
                            ${modelQueries.join(' UNION ALL ')}
                        )
                        SELECT 
                            DATE_TRUNC('year', '1981-01-01'::TIMESTAMP + INTERVAL (ix) HOUR) as date,
                            model_name,
                            AVG(flow_ls) as total_flow,
                            AVG(flow_ls) as avg_flow,
                            MIN(flow_ls) as min_flow,
                            MAX(flow_ls) as max_flow
                        FROM combined_data
                        GROUP BY date, model_name
                        ORDER BY date, model_name
                    `;
                }

                const result = await conn.query(query);
                currentData = result.toArray().map(row => row.toJSON());
                conn.close();

                // Debug: Log sample data structure
                console.log('Sample data:', currentData.slice(0, 5));
                console.log(`Total data points: ${currentData.length}`);
                
                const uniqueModels = [...new Set(currentData.map(row => row.model_name))];
                console.log(`Unique models in data: ${uniqueModels.join(', ')}`);

                createChart(currentData, 'suro+ifwo', aggregation, chartType);
                createTable(currentData);

                document.getElementById('chart-section').style.display = 'block';
                document.getElementById('table-section').style.display = 'block';

                showStatus('Analysis complete!', 'success');

            } catch (error) {
                console.error('Error analyzing data:', error);
                showStatus('Error analyzing data: ' + error.message, 'danger');
            }
        }

        // Create chart
        function createChart(data, variable, aggregation, chartType) {
            const ctx = document.getElementById('time-series-chart').getContext('2d');
            
            if (chart) {
                chart.destroy();
            }

            // Group data by date and compute ensemble statistics
            const dateData = {};
            const allDates = new Set();
            
            data.forEach(row => {
                const dateStr = new Date(row.date).toISOString().split('T')[0];
                
                if (!dateData[dateStr]) {
                    dateData[dateStr] = [];
                }
                dateData[dateStr].push({
                    model: row.model_name,
                    value: row.total_flow
                });
                allDates.add(dateStr);
            });

            // Sort dates chronologically
            const sortedDates = Array.from(allDates).sort();
            const displayDates = sortedDates.map(date => new Date(date).toLocaleDateString());

            let datasets = [];
            let chartTitle = '';

            if (chartType === 'range') {
                // Calculate ensemble statistics for each date
                const ensembleStats = sortedDates.map(date => {
                    const values = dateData[date]?.map(d => d.value) || [];
                    if (values.length === 0) return { min: null, max: null, mean: null };
                    
                    return {
                        min: Math.min(...values),
                        max: Math.max(...values),
                        mean: values.reduce((sum, val) => sum + val, 0) / values.length
                    };
                });

                const minValues = ensembleStats.map(stat => stat.min);
                const maxValues = ensembleStats.map(stat => stat.max);
                const meanValues = ensembleStats.map(stat => stat.mean);

                datasets = [
                    {
                        label: 'Model Range',
                        data: maxValues,
                        borderColor: 'rgba(75, 192, 192, 0.8)',
                        backgroundColor: 'rgba(75, 192, 192, 0.3)',
                        borderWidth: 1,
                        tension: 0.1,
                        fill: '+1',
                        pointRadius: 0,
                        pointHoverRadius: 3
                    },
                    {
                        label: 'Model Range (Min)',
                        data: minValues,
                        borderColor: 'rgba(75, 192, 192, 0.8)',
                        backgroundColor: 'rgba(75, 192, 192, 0.3)',
                        borderWidth: 1,
                        tension: 0.1,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 3
                    },
                    {
                        label: 'Ensemble Mean',
                        data: meanValues,
                        borderColor: 'rgb(255, 99, 132)',
                        backgroundColor: 'rgba(255, 99, 132, 0.1)',
                        borderWidth: 3,
                        tension: 0.1,
                        fill: false,
                        pointRadius: 2,
                        pointHoverRadius: 5
                    }
                ];

                chartTitle = `Model Ensemble Range: Surface Runoff + Interflow (${aggregation} aggregation)`;
            } else {
                // Individual model lines (original behavior)
                const modelData = {};
                
                data.forEach(row => {
                    const model = row.model_name;
                    const dateStr = new Date(row.date).toISOString().split('T')[0];
                    
                    if (!modelData[model]) {
                        modelData[model] = [];
                    }
                    modelData[model].push({
                        date: dateStr,
                        value: row.total_flow
                    });
                });

                const colors = [
                    'rgb(75, 192, 192)',    'rgb(255, 99, 132)',    'rgb(54, 162, 235)',
                    'rgb(255, 205, 86)',    'rgb(153, 102, 255)',   'rgb(255, 159, 64)',
                    'rgb(46, 125, 50)',     'rgb(156, 39, 176)',    'rgb(255, 87, 34)',
                    'rgb(0, 150, 136)',     'rgb(121, 85, 72)',     'rgb(96, 125, 139)'
                ];

                datasets = Object.keys(modelData).map((model, index) => {
                    const sortedModelData = modelData[model].sort((a, b) => a.date.localeCompare(b.date));
                    const modelValues = sortedDates.map(date => {
                        const dataPoint = sortedModelData.find(d => d.date === date);
                        return dataPoint ? dataPoint.value : null;
                    });
                    
                    const modelDisplayName = model.length > 25 ? model.substring(0, 25) + '...' : model;
                    
                    return {
                        label: modelDisplayName,
                        data: modelValues,
                        borderColor: colors[index % colors.length],
                        backgroundColor: colors[index % colors.length].replace('rgb', 'rgba').replace(')', ', 0.1)'),
                        borderWidth: 2,
                        tension: 0.1,
                        fill: false,
                        pointRadius: 2,
                        pointHoverRadius: 5
                    };
                });

                chartTitle = `Multi-Model Comparison: Surface Runoff + Interflow (${aggregation} aggregation)`;
            }

            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: displayDates,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: chartTitle,
                            font: {
                                size: 16
                            }
                        },
                        legend: {
                            position: 'top',
                            labels: {
                                usePointStyle: true,
                                padding: 15,
                                font: {
                                    size: 11
                                },
                                filter: function(legendItem) {
                                    // Hide the "Model Range (Min)" legend item for cleaner display
                                    return legendItem.text !== 'Model Range (Min)';
                                }
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                title: function(context) {
                                    return `Date: ${context[0].label}`;
                                },
                                label: function(context) {
                                    const value = context.parsed.y;
                                    if (value !== null) {
                                        if (chartType === 'range') {
                                            if (context.dataset.label === 'Model Range') {
                                                const minValue = context.chart.data.datasets[1].data[context.dataIndex];
                                                return `Model Range: ${minValue?.toFixed(2)} - ${value.toFixed(2)} L/s`;
                                            } else if (context.dataset.label === 'Ensemble Mean') {
                                                return `Ensemble Mean: ${value.toFixed(2)} L/s`;
                                            }
                                        } else {
                                            return `${context.dataset.label}: ${value.toFixed(2)} L/s`;
                                        }
                                    }
                                    return `${context.dataset.label}: No data`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Surface Runoff + Interflow (L/s)',
                                font: {
                                    size: 12,
                                    weight: 'bold'
                                }
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Date',
                                font: {
                                    size: 12,
                                    weight: 'bold'
                                }
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            },
                            ticks: {
                                maxTicksLimit: 10,
                                maxRotation: 45
                            }
                        }
                    },
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    elements: {
                        line: {
                            tension: 0.1
                        }
                    }
                }
            });

            // Add logging info
            if (chartType === 'range') {
                const modelCount = new Set(data.map(row => row.model_name)).size;
                console.log(`Ensemble chart created with ${modelCount} models showing range and mean`);
            } else {
                const modelCount = Object.keys(datasets).length;
                console.log(`Individual model chart created with ${modelCount} models`);
            }
        }

        // Create data table
        function createTable(data) {
            const container = document.getElementById('table-container');
            const startIdx = (currentPage - 1) * rowsPerPage;
            const endIdx = startIdx + rowsPerPage;
            const pageData = data.slice(startIdx, endIdx);

            let html = '<table class="table table-striped table-hover"><thead><tr>';
            
            if (data.length > 0) {
                Object.keys(data[0]).forEach(key => {
                    html += `<th>${key}</th>`;
                });
                html += '</tr></thead><tbody>';

                pageData.forEach(row => {
                    html += '<tr>';
                    Object.values(row).forEach(value => {
                        html += `<td>${value}</td>`;
                    });
                    html += '</tr>';
                });
                html += '</tbody></table>';
            }

            container.innerHTML = html;
            createPagination(data.length);
        }

        // Create pagination
        function createPagination(totalItems) {
            const totalPages = Math.ceil(totalItems / rowsPerPage);
            const container = document.getElementById('pagination-container');
            
            let html = '<nav><ul class="pagination justify-content-center">';
            
            for (let i = 1; i <= totalPages; i++) {
                html += `<li class="page-item ${i === currentPage ? 'active' : ''}">
                    <a class="page-link" href="#" onclick="changePage(${i})">${i}</a>
                </li>`;
            }
            
            html += '</ul></nav>';
            container.innerHTML = html;
        }

        // Change page
        window.changePage = function(page) {
            currentPage = page;
            createTable(currentData);
        };

        // Download CSV
        function downloadCSV() {
            if (currentData.length === 0) return;

            const headers = Object.keys(currentData[0]);
            const csvContent = [
                headers.join(','),
                ...currentData.map(row => 
                    headers.map(header => 
                        `"${row[header]}"`
                    ).join(',')
                )
            ].join('\n');

            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `hru_analysis_${new Date().getTime()}.csv`;
            a.click();
            window.URL.revokeObjectURL(url);
        }

        // Event listeners
        addModelButton.addEventListener('click', addModelRow);
        gridSelect.addEventListener('change', updateDataSource);
        addHruButton.addEventListener('click', addHruRow);
        loadDataButton.addEventListener('click', loadData);
        document.getElementById('analyze-data').addEventListener('click', analyzeData);
        document.getElementById('download-csv').addEventListener('click', downloadCSV);

        // Initialize everything
        document.addEventListener('DOMContentLoaded', async () => {
            await loadSelectionData();
            await initDuckDB();
            // Add default rows
            addModelRow();
            addHruRow();
        });
    </script>
</body>
</html>